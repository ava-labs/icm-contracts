// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: LicenseRef-Ecosystem

pragma solidity 0.8.25;

import {IERC20} from "@openzeppelin/contracts@5.0.2/token/ERC20/IERC20.sol";
import {IValidatorManager} from "./interfaces/IValidatorManager.sol";
import {PChainOwner} from "./interfaces/IACP99Manager.sol";
import {Heap} from "@openzeppelin/contracts@5.0.2/utils/structs/Heap.sol";
import {ReentrancyGuardUpgradeable} from
    "@openzeppelin/contracts-upgradeable@5.0.2/utils/ReentrancyGuardUpgradeable.sol";
import {ContextUpgradeable} from
    "@openzeppelin/contracts-upgradeable@5.0.2/utils/ContextUpgradeable.sol";
import {Comparators} from "@openzeppelin/contracts@5.0.2/utils/Comparators.sol";
import "@openzeppelin/contracts@5.0.2/utils/math/Math.sol";
struct ValidatorBid {
    address addr;
    uint256 bid;
    bytes nodeID;
    bytes blsPublicKey;
    PChainOwner remainingBalanceOwner;
    PChainOwner disableOwner;
}

struct ValidatorInfo {
    address addr;
    uint256 endTime;
    bytes nodeID;
    bytes blsPublicKey;
    bytes32 validationID;
    uint64 Weight;
}

contract SlotAuctionManager is ReentrancyGuardUpgradeable, ContextUpgradeable {
    using Heap for Heap.Uint256Heap;

    event NewValidatorAuction(uint16 validatorSlots, uint64 validatorWeight, uint256 validationTimeLimit, uint256 auctionEndTime);
    event SuccessfulBidPlaced(uint256 indexed bid, bytes indexed nodeID);
    event BidEvicted(uint256 indexed bid, bytes indexed nodeID);
    event InitiatedAuctionValidatorRegistration(bytes32 indexed validationID, address indexed ownerAddress, uint256 endtime);

    IERC20 public TOKEN_CONTRACT;
    IValidatorManager public VALIDATOR_MANAGER;
    bool public auctionInProgress;
    // auctionEndTime is the last second users can place bids
    uint256 public auctionEndTime;
    uint16 public validatorSlots;
    uint64 public validatorWeight;
    uint256 public validationTimeLimit;
    uint256 public minimumBid;
    // checks to see if the NodeID is currently in the heap
    mapping (bytes nodeID => bool isQualified) private _nodeIsQualified; 
    mapping (bytes nodeID => ValidatorInfo) public validatorsByNodeID;
    mapping (bytes32 validationID => ValidatorInfo) public validatorsByValidationID;
    mapping (uint256 bid => ValidatorBid) public bidderInfo;
    uint256 private _secondPrice;
    // I dont know why, but making this public causes it to fail, so I made it internal, something about autogenerated getter functions
    Heap.Uint256Heap internal _bids;

    modifier AuctionInProgress {
        require(auctionInProgress, "Auction not in progress");
        _;
    }

    constructor(address tokenAddress, address vmAddress) {
        TOKEN_CONTRACT = IERC20(tokenAddress);
        VALIDATOR_MANAGER = IValidatorManager(vmAddress);
    }

    // TODO replace this ^ with this v once I know it wont cause issues for me

    // function initialize(address tokenAddress, address vmAddress)public initializer {
    //     TOKEN_CONTRACT = IERC20(tokenAddress);
    //     VALIDATOR_MANAGER = IValidatorManager(vmAddress);
    // }

    
    function initiateAuction(
        uint16 validatorslots,
        uint64 weight,
        uint256 auctionLength,
        uint256 validationLength,
        uint256 minimumbid
    ) external {
        require(!auctionInProgress, "Auction currently in progress");
        validatorWeight = weight;
        // require(only owner can call this contract)
        // require(churn percentage will not be overlooked)
        // Things to add:
        // no re entry
        // probably a lot more
        
        auctionEndTime = block.timestamp + auctionLength; 
        validatorSlots = validatorslots;
        validationTimeLimit = validationLength;
        minimumBid = minimumbid;
        _secondPrice = 0;
        // Initiates an empty heap array, id rather just create a new one but solidity memory syntax is still confusing to me
        delete _bids.tree; 
        auctionInProgress = true;
        emit NewValidatorAuction(validatorSlots, weight, validationLength, auctionLength);
    }

    function placeBid (
        uint256 bid,
        bytes memory nodeID,
        bytes memory blsPublicKey,
        PChainOwner memory remainingBalanceOwner,
        PChainOwner memory disableOwner
    ) AuctionInProgress external {
        require(validatorsByNodeID[nodeID].addr == address(0), "Node is already a validator");
        require(!_nodeIsQualified[nodeID], "Node is already in a winning position");
        require(bidderInfo[bid].addr == address(0), "Duplicate bid in running");
        require(bid >= minimumBid, "Bid lower than minimum bid");
        require(VALIDATOR_MANAGER.getNodeValidationID(nodeID) == 0, "NodeID already validator");

        // If all slots aren't contended, then fill the heap with any bid
        if (Heap.length(_bids) < validatorSlots) {
            require (TOKEN_CONTRACT.transferFrom(msg.sender, address(this), bid), "Insufficient funds to bid");
            Heap.insert(_bids, bid);
        } 
        else if (Heap.peek(_bids) < bid) {
            require (TOKEN_CONTRACT.transferFrom(msg.sender, address(this), bid), "Insufficient funds to bid");
            uint256 poppedBid = Heap.replace(_bids, bid);
            _secondPrice = poppedBid;
            emit BidEvicted(poppedBid, bidderInfo[poppedBid].nodeID);
            // send back held funds if lost auction
            TOKEN_CONTRACT.transfer(bidderInfo[poppedBid].addr, poppedBid);

            // deletes info of bidder no longer needed along with replacing it in the heap
            delete _nodeIsQualified[bidderInfo[poppedBid].nodeID];
            delete bidderInfo[poppedBid]; 
        }
        else {
            revert("Bid not high enough to win auction");
        }
        bidderInfo[bid] = ValidatorBid(msg.sender, bid, nodeID, blsPublicKey, remainingBalanceOwner, disableOwner);
        _nodeIsQualified[nodeID] = true;
        emit SuccessfulBidPlaced(bid, nodeID);
    }

    function endAuction() AuctionInProgress external {
        // TODO: only owner
        require(block.timestamp > auctionEndTime, "Auction endtime not reached");
        auctionInProgress = false; 
        auctionEndTime = 0;

        // avoids array out of bounds for Heap.peek
        if (_secondPrice == 0 && Heap.length(_bids) != 0) { 
            _secondPrice = Heap.peek(_bids);
        }

        while (Heap.length(_bids) > 0) {
            uint256 currentBid = Heap.pop(_bids);
            ValidatorBid memory bidInfo = bidderInfo[currentBid];

            // sends back extra tokens due to second price
            TOKEN_CONTRACT.transfer(bidInfo.addr, currentBid - _secondPrice);
            
            bytes32 validationID = VALIDATOR_MANAGER.initiateValidatorRegistration(
                bidInfo.nodeID, bidInfo.blsPublicKey, bidInfo.remainingBalanceOwner, bidInfo.disableOwner, validatorWeight
            );

            emit InitiatedAuctionValidatorRegistration(validationID, bidInfo.addr, validationTimeLimit + auctionEndTime);
            validatorsByNodeID[bidInfo.nodeID] = ValidatorInfo(bidInfo.addr, validationTimeLimit + auctionEndTime, bidInfo.nodeID, bidInfo.blsPublicKey, validationID, validatorWeight);
            validatorsByValidationID[validationID] = ValidatorInfo(bidInfo.addr, validationTimeLimit + auctionEndTime, bidInfo.nodeID, bidInfo.blsPublicKey, validationID, validatorWeight);
            _secondPrice = currentBid;
        }
        
        validatorSlots = 0;
        validationTimeLimit = 0;
    }

    function initiateValidatorRemoval(
        bytes32 validationID
    ) public {
        // if validationID doesnt exist then endtime will be 0, however it wont be logged in the Validator Manager either so this should be ok
        require(validatorsByValidationID[validationID].endTime < block.timestamp, "Validation time limit has not ended");
        delete validatorsByNodeID[validatorsByValidationID[validationID].nodeID];
        delete validatorsByValidationID[validationID];
        VALIDATOR_MANAGER.initiateValidatorRemoval(validationID);
    }
    
    // working on removing this, along with making the contract upgradeable, removing it right now makes the e2e tests fail
    function initiateRemoveInitialValidator(
        bytes32 validationID
    ) public {
        VALIDATOR_MANAGER.initiateValidatorRemoval(validationID);
    }

    function completeRemoveInitialValidator(
        uint32 messageIndex
    ) public {
        VALIDATOR_MANAGER.completeValidatorRemoval(messageIndex);
    }
    
    function completeValidatorRegistration(
        uint32 messageIndex
    ) public returns (bytes32) {
        return VALIDATOR_MANAGER.completeValidatorRegistration(messageIndex);
    }

    function completeValidatorRemoval(
        uint32 messageIndex
    ) public returns (bytes32) {
        return VALIDATOR_MANAGER.completeValidatorRemoval(messageIndex);
    }
    
    function peekTop () AuctionInProgress public view returns (uint256){
        if (Heap.length(_bids) == 0) {
            return 0;
        }
        return Heap.peek(_bids);
    }
}  
