// (c) 2025, Ava Labs, Inc. All rights reserved.
// See the file LICENSE for licensing terms.

// SPDX-License-Identifier: LicenseRef-Ecosystem

pragma solidity 0.8.25;

import {IERC20} from "@openzeppelin/contracts@5.0.2/token/ERC20/IERC20.sol";
import {IValidatorManager} from "./interfaces/IValidatorManager.sol";
import {PChainOwner} from "./interfaces/IACP99Manager.sol";
import {EmCoin} from "./EmCoin.sol";
import {Heap} from "@openzeppelin/contracts@5.0.2/utils/structs/Heap.sol";
//TODO: make these constant and also public, prob some way to store it in memory or something from here

struct ValidatorBid {
    address addr;
    uint256 bid;
    bytes nodeID;
    bytes blsPublicKey;
    PChainOwner remainingBalanceOwner;
    PChainOwner disableOwner;
}

struct ValidatorInfo {
    address addr;
    uint256 endTime;
    bytes nodeID;
    bytes blsPublicKey;
    uint32 validationID;
}

contract SlotAuctionManager {
    using Heap for Heap.Uint256Heap;

    IERC20 public TOKEN_CONTRACT;
    IValidatorManager public VALIDATOR_MANAGER;
    bool public auctionInProgress = false;
    uint256 public auctionEndTime = 0;
    uint16 public validatorSlots = 0;
    uint64 public validatorWeight = 0;
    uint256 public validationTimeLimit = 0;
    mapping (bytes nodeID => bool hasBid) public nodeHasBid;
    mapping (bytes nodeID => ValidatorInfo) public currentValidators;
    mapping (uint256 bid => ValidatorBid) public bidderInfo;
    Heap.Uint256Heap internal _bids; //I dont know why, but making this public causes it to fail, so I made it internal, something about autogenerated getter functions
    function(uint256, uint256) external view returns (bool) public customComparator;


    constructor(address tokenAddress, address vmAddress) {
        TOKEN_CONTRACT = IERC20(tokenAddress);
        VALIDATOR_MANAGER = IValidatorManager(vmAddress);
    }
    
    function initiateAuction(
        uint16 validatorslots,
        uint64 weight,
        uint256 auctionLength,
        uint256 validationLength
    ) external {
        require(!auctionInProgress, "Auction already running");
        validatorWeight = weight;
        //require(only owner can call this contract)
        //require(churn percentage will not be overlooked)
        //Things to add:
        //no re entry
        //probably a lot more
       
        auctionEndTime = block.timestamp + auctionLength; //sets the minimum end time of the auction, can go over
        validatorSlots = validatorslots;
        validationTimeLimit = validationLength;
       
        delete _bids.tree; //initiates an empty heap array, id rather just create a new one but solidity memory syntax is still confusing to me
        auctionInProgress = true;
    }

    function endAuction() external returns (bool) {
        //only owner
        require(auctionInProgress, "Auction not in progress");
        require(block.timestamp > auctionEndTime, "Before set end of auction time"); //gotta word this better

        auctionInProgress = false; //set auction to false so no more bids can come in
        auctionEndTime = 0;
        
        if (Heap.length(_bids) < validatorSlots + 1) {
            uint256 bid = Heap.peek(_bids);
            ValidatorBid memory bidInfo = bidderInfo[bid];
            _initiateValidatorRegistration(bidInfo.nodeID, bidInfo.blsPublicKey, bidInfo.remainingBalanceOwner, bidInfo.disableOwner, validatorWeight);
        }
        
        while (Heap.length(_bids) != 0) {
            //gets the second price and pops it
            uint256 previousBid = Heap.peek(_bids);
            Heap.pop(_bids);
            //gets the current bid info and also calculates how many tokens need to be returned due to second price difference
            uint256 currentBid = Heap.peek(_bids);
            uint256 tokenRefund = currentBid - previousBid;
            ValidatorBid memory bidInfo = bidderInfo[currentBid];
            TOKEN_CONTRACT.transfer(bidInfo.addr, tokenRefund);
            _initiateValidatorRegistration(bidInfo.nodeID, bidInfo.blsPublicKey, bidInfo.remainingBalanceOwner, bidInfo.disableOwner, validatorWeight);
        }
        
        validatorSlots = 0;
        validationTimeLimit = 0;
        
        return true;
    }

    
    function placeBid(
        uint256 bid,
        bytes memory nodeID,
        bytes memory blsPublicKey,
        PChainOwner memory remainingBalanceOwner,
        PChainOwner memory disableOwner
    ) external {
        require(auctionInProgress, "Auction is not running");
        nodeHasBid[nodeID] = true; //immediately label them as bid, this makes it so they cant spam bid even if they already bid a smaller amount
        customComparator = this.minHeapCompare;
        if (Heap.length(_bids) == 0) {
            Heap.insert(_bids, bid, customComparator);
        }
        if (Heap.peek(_bids) > bid && Heap.length(_bids) >= validatorSlots + 1) { // if heap is full and current bid is too small, ignore it and dont bother taking tokens
            return; 
        }
        require (TOKEN_CONTRACT.transferFrom(msg.sender, address(this), bid), "Insufficient funds based on bid");
        //We dont want duplicate bids since a victor then becomes quesitonable, and it also messes up the mapping in general
        //We should have it set to either allow another bid (whats in place already) or, we slightly reduce their bid to a number that is available 
        require (bidderInfo[bid].addr == address(0) && bidderInfo[bid].bid == 0, "Bid already placed, you may bid again");
        if (Heap.length(_bids) >= validatorSlots + 1) {
            uint256 poppedValue = Heap.replace(_bids, bid, customComparator); //removes the smallest value from the heap, keeping size low
            TOKEN_CONTRACT.transfer(bidderInfo[poppedValue].addr, bidderInfo[poppedValue].bid); 
            delete bidderInfo[poppedValue];
        }
        else {
            Heap.insert(_bids, bid, customComparator);
        }
        bidderInfo[bid] = ValidatorBid(msg.sender, bid, nodeID, blsPublicKey, remainingBalanceOwner, disableOwner);
    }

    function minHeapCompare(uint256 a, uint256 b) public view returns (bool) {
        return a < b;
    }

    function initiateValidatorRemoval(
        bytes32 validationID
    ) public {
        VALIDATOR_MANAGER.initiateValidatorRemoval(validationID);
    }
    function initiateRemoveInitialValidator(
        bytes32 validationID
    ) public {
        VALIDATOR_MANAGER.initiateValidatorRemoval(validationID);
    }

    function completeRemoveInitialValidator(
        uint32 messageIndex
    ) public {
        VALIDATOR_MANAGER.completeValidatorRemoval(messageIndex);
    }
    
    function completeValidatorRegistration(
        uint32 messageIndex
    ) public returns (bytes32) {
        return VALIDATOR_MANAGER.completeValidatorRegistration(messageIndex);
    }

    function completeValidatorRemoval(
        uint32 messageIndex
    ) public returns (bytes32) {
        return VALIDATOR_MANAGER.completeValidatorRemoval(messageIndex);
    }
    
    
    function peekTop () public view returns (uint256){
        if (Heap.length(_bids) == 0 || !auctionInProgress) {
            return 0;
        }
        return Heap.peek(_bids);
    }

    function _initiateValidatorRegistration(
        bytes memory nodeID,
        bytes memory blsPublicKey,
        PChainOwner memory remainingBalanceOwner,
        PChainOwner memory disableOwner,
        uint64 weight
    ) internal returns (bytes32) {
        bytes32 validationID = VALIDATOR_MANAGER.initiateValidatorRegistration(
            nodeID, blsPublicKey, remainingBalanceOwner, disableOwner, weight
        );
        return validationID;
    }



}  
